<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of Radar</title>
  <meta name="keywords" content="Radar">
  <meta name="description" content="A class representing a Radar system">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">radar-object</a> &gt; Radar.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for radar-object&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>Radar
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>A class representing a Radar system</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> A class representing a Radar system

 TODO:
 - Allow the user to create a pulse train with multiple types of waveforms
 - Add multistatic capabilities

 Blame: Shane Flandermeyer</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="RFSystem.html" class="code" title="">RFSystem</a>	An abstract class representing a notional RF front end.</li><li><a href="Radar.html" class="code" title="">Radar</a>	A class representing a Radar system</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="Radar.html" class="code" title="">Radar</a>	A class representing a Radar system</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function set.num_pulses(obj,val)</a></li><li><a href="#_sub2" class="code">function set.prf(obj,val)</a></li><li><a href="#_sub3" class="code">function set.pri(obj,val)</a></li><li><a href="#_sub4" class="code">function set.waveform(obj,val)</a></li><li><a href="#_sub5" class="code">function set.antenna(obj,val)</a></li><li><a href="#_sub6" class="code">function out = get.range_resolution(obj)</a></li><li><a href="#_sub7" class="code">function out = get.num_pulses(obj)</a></li><li><a href="#_sub8" class="code">function out = get.prf(obj)</a></li><li><a href="#_sub9" class="code">function out = get.pri(obj)</a></li><li><a href="#_sub10" class="code">function out = get.waveform(obj)</a></li><li><a href="#_sub11" class="code">function out = get.antenna(obj)</a></li><li><a href="#_sub12" class="code">function out = get.doppler_unambig(obj)</a></li><li><a href="#_sub13" class="code">function out = get.range_unambig(obj)</a></li><li><a href="#_sub14" class="code">function out = get.velocity_unambig(obj)</a></li><li><a href="#_sub15" class="code">function cnr = CNR(obj,clutter,angle,range)</a></li><li><a href="#_sub16" class="code">function range = measuredRange(obj,targets)</a></li><li><a href="#_sub17" class="code">function range = trueRange(obj,targets)</a></li><li><a href="#_sub18" class="code">function doppler = measuredDoppler(obj,targets)</a></li><li><a href="#_sub19" class="code">function velocity = measuredVelocity(obj,targets)</a></li><li><a href="#_sub20" class="code">function phase = roundTripPhase(obj,targets)</a></li><li><a href="#_sub21" class="code">function power = receivedPower(obj,targets)</a></li><li><a href="#_sub22" class="code">function pulses = pulseBurstWaveform(obj)</a></li><li><a href="#_sub23" class="code">function mf = pulseBurstMatchedFilter(obj)</a></li><li><a href="#_sub24" class="code">function pulses = pulseMatrix(obj)</a></li><li><a href="#_sub25" class="code">function out = simulateTargets(obj,targets,data)</a></li><li><a href="#_sub26" class="code">function out = simulateTargetsPulseBurst(obj,targets,data)</a></li><li><a href="#_sub27" class="code">function [mf_resp,range_axis] = matchedFilterResponse(obj,data)</a></li><li><a href="#_sub28" class="code">function [rd_map,velocity_axis] = dopplerProcessing(obj,data,oversampling)</a></li><li><a href="#_sub29" class="code">function snr = SNR(obj,targets)</a></li><li><a href="#_sub30" class="code">function out = delaySequence(data,delay)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% A class representing a Radar system</span>
0002 <span class="comment">%</span>
0003 <span class="comment">% TODO:</span>
0004 <span class="comment">% - Allow the user to create a pulse train with multiple types of waveforms</span>
0005 <span class="comment">% - Add multistatic capabilities</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% Blame: Shane Flandermeyer</span>
0008 classdef <a href="Radar.html" class="code" title="">Radar</a> &lt; matlab.mixin.Copyable &amp; <a href="RFSystem.html" class="code" title="">RFSystem</a>
0009   
0010   <span class="comment">%% Private properties</span>
0011   properties (Access = private)
0012     <span class="comment">% List of parameters that should be updated when we change the scale</span>
0013     <span class="comment">% from linear to dB or vice versa</span>
0014     power_list = {<span class="string">'loss_system'</span>,<span class="string">'noise_fig'</span>};
0015   <span class="keyword">end</span>
0016   
0017   <span class="comment">% Members exposed to the outside world</span>
0018   properties (Dependent)
0019     antenna;          <span class="comment">% Antenna object</span>
0020     waveform;         <span class="comment">% Waveform object</span>
0021     prf;              <span class="comment">% Pulse repetition frequency (Hz)</span>
0022     pri;              <span class="comment">% Pulse repetition interval (s)</span>
0023     num_pulses;       <span class="comment">% Number of pulses in a CPI</span>
0024     range_unambig;    <span class="comment">% Unambiguous range (m)</span>
0025     velocity_unambig; <span class="comment">% Unambiguous velocity (m/s)</span>
0026     doppler_unambig;  <span class="comment">% Unambiguous doppler frequency (Hz)</span>
0027     range_resolution; <span class="comment">% Range resolution (m)</span>
0028   <span class="keyword">end</span>
0029   
0030   <span class="comment">% Internal class data</span>
0031   properties (Access = protected)
0032     d_antenna;
0033     d_waveform;
0034     d_prf;
0035     d_pri;
0036     d_num_pulses;
0037   <span class="keyword">end</span>
0038   
0039   
0040   <span class="comment">%% Setter Methods</span>
0041   methods
0042     
0043     <a name="_sub0" href="#_subfunctions" class="code">function set.num_pulses(obj,val)</a>
0044       
0045       validateattributes(val,{<span class="string">'numeric'</span>},{<span class="string">'finite'</span>,<span class="string">'nonnan'</span>,<span class="string">'nonnegative'</span>});
0046       obj.d_num_pulses = val;
0047       
0048     <span class="keyword">end</span>
0049     
0050     <a name="_sub1" href="#_subfunctions" class="code">function set.prf(obj,val)</a>
0051       
0052       validateattributes(val,{<span class="string">'numeric'</span>},{<span class="string">'finite'</span>,<span class="string">'nonnan'</span>,<span class="string">'nonnegative'</span>});
0053       obj.d_prf = val;
0054       obj.d_pri = 1 / obj.d_prf;
0055       
0056     <span class="keyword">end</span>
0057     
0058     <a name="_sub2" href="#_subfunctions" class="code">function set.pri(obj,val)</a>
0059       
0060       validateattributes(val,{<span class="string">'numeric'</span>},{<span class="string">'finite'</span>,<span class="string">'nonnan'</span>,<span class="string">'nonnegative'</span>});
0061       obj.d_pri = val;
0062       obj.d_prf = 1 / obj.d_pri;
0063       
0064     <span class="keyword">end</span>
0065     
0066     <a name="_sub3" href="#_subfunctions" class="code">function set.waveform(obj,val)</a>
0067       
0068       validateattributes(val,{<span class="string">'Waveform'</span>},{});
0069        obj.d_waveform = val;
0070        
0071     <span class="keyword">end</span>
0072     
0073     <a name="_sub4" href="#_subfunctions" class="code">function set.antenna(obj,val)</a>
0074       
0075       validateattributes(val,{<span class="string">'Antenna'</span>,<span class="string">'AntennaArray'</span>},{});
0076       obj.d_antenna = val;
0077       
0078     <span class="keyword">end</span>
0079     
0080   <span class="keyword">end</span>
0081   
0082   <span class="comment">%% Getter Methods</span>
0083   methods
0084     
0085     <a name="_sub5" href="#_subfunctions" class="code">function out = get.range_resolution(obj)</a>
0086       out = obj.const.c/2/obj.bandwidth;
0087     <span class="keyword">end</span>
0088     
0089     <a name="_sub6" href="#_subfunctions" class="code">function out = get.num_pulses(obj)</a>
0090       out = obj.d_num_pulses;
0091     <span class="keyword">end</span>
0092     
0093     <a name="_sub7" href="#_subfunctions" class="code">function out = get.prf(obj)</a>
0094       out = obj.d_prf;
0095     <span class="keyword">end</span>
0096     
0097     <a name="_sub8" href="#_subfunctions" class="code">function out = get.pri(obj)</a>
0098       out = obj.d_pri;
0099     <span class="keyword">end</span>
0100     
0101     <a name="_sub9" href="#_subfunctions" class="code">function out = get.waveform(obj)</a>
0102       out = obj.d_waveform;
0103     <span class="keyword">end</span>
0104     
0105     <a name="_sub10" href="#_subfunctions" class="code">function out = get.antenna(obj)</a>
0106       out = obj.d_antenna;
0107     <span class="keyword">end</span>
0108     
0109     <a name="_sub11" href="#_subfunctions" class="code">function out = get.doppler_unambig(obj)</a>
0110       <span class="comment">% Calculate the unambiguous doppler</span>
0111       out = obj.prf/2;
0112     <span class="keyword">end</span>
0113     
0114     <a name="_sub12" href="#_subfunctions" class="code">function out = get.range_unambig(obj)</a>
0115       <span class="comment">% Calculate the unambiguous range</span>
0116       out = obj.const.c*obj.pri/2;
0117     <span class="keyword">end</span>
0118     
0119     <a name="_sub13" href="#_subfunctions" class="code">function out = get.velocity_unambig(obj)</a>
0120       <span class="comment">% Calculate the unambiguous velocity</span>
0121       out = obj.wavelength*obj.prf/4;
0122     <span class="keyword">end</span>
0123   <span class="keyword">end</span>
0124   
0125   <span class="comment">%% Public Methods</span>
0126   methods
0127     
0128     <a name="_sub14" href="#_subfunctions" class="code">function cnr = CNR(obj,clutter,angle,range)</a>
0129       <span class="comment">% Calculates the clutter-to-noise ratio for the given clutter at the</span>
0130       <span class="comment">% given range and angles</span>
0131       
0132       <span class="keyword">if</span> (~isa(obj.antenna,<span class="string">'AntennaArray'</span>))
0133         error(<span class="string">'This function currently only supports AntennaArray objects'</span>)
0134       <span class="keyword">end</span>
0135       
0136       was_db = false;
0137       <span class="keyword">if</span> strcmpi(obj.scale,<span class="string">'dB'</span>)
0138         was_db = true;
0139         obj.scale = <span class="string">'Linear'</span>;
0140       <span class="keyword">end</span>
0141       
0142       was_degrees = false;
0143       <span class="keyword">if</span> strcmpi(obj.antenna.angle_unit,<span class="string">'Degrees'</span>)
0144         was_degrees = true;
0145         obj.antenna.angle_unit = <span class="string">'Radians'</span>;
0146       <span class="keyword">end</span> 
0147       
0148       AF = obj.antenna.arrayFactor(angle);
0149       Gt = obj.antenna.gain_tx*(abs(AF).^2).*<span class="keyword">...</span>
0150         obj.antenna.elements(1,1).normPowerGain(angle);
0151       g = obj.antenna.gain_element*obj.antenna.gain_rx*<span class="keyword">...</span>
0152         obj.antenna.elements(1,1).normPowerGain(angle);
0153 <span class="comment">%       Gt = 10^(obj.antenna.gain_tx/10)*(abs(AF).^2).*...</span>
0154 <span class="comment">%         obj.antenna.elements(1,1).normPowerGain(angle);</span>
0155 <span class="comment">%       g = 10^(obj.antenna.gain_element/10).*...</span>
0156 <span class="comment">%         10^(obj.antenna.gain_rx/10)*obj.antenna.elements(1,1).normPowerGain(angle);</span>
0157       sigma = clutter.patchRCS(obj,range);
0158       
0159       cnr = obj.power_tx*Gt.*g*obj.wavelength^2*sigma/((4*pi)^3*<span class="keyword">...</span>
0160         obj.power_noise*obj.loss_system*range^4);
0161       
0162       <span class="keyword">if</span> was_degrees
0163         obj.antenna.angle_unit = <span class="string">'Degrees'</span>;
0164       <span class="keyword">end</span>
0165       
0166       
0167       <span class="keyword">if</span> was_db
0168         obj.scale = <span class="string">'db'</span>;
0169         cnr = 10*log10(cnr);
0170       <span class="keyword">end</span>
0171     <span class="keyword">end</span>
0172     
0173     <a name="_sub15" href="#_subfunctions" class="code">function range = measuredRange(obj,targets)</a>
0174       <span class="comment">% For each target in the list, calculate the range measured by the</span>
0175       <span class="comment">% radar, accounting for range ambiguities;</span>
0176       range = obj.trueRange(targets);
0177       <span class="keyword">for</span> ii = 1:length(range)
0178         <span class="comment">% Get the projection of the position vector onto the mainbeam pointing</span>
0179         <span class="comment">% vector</span>
0180         range(ii) = mod(range(ii),obj.range_unambig);
0181       <span class="keyword">end</span>
0182     <span class="keyword">end</span> <span class="comment">% measuredRange()</span>
0183     
0184     <a name="_sub16" href="#_subfunctions" class="code">function range = trueRange(obj,targets)</a>
0185       <span class="comment">% For each target in the list, calculate the true range of the target from</span>
0186       <span class="comment">% the radar</span>
0187       range = vecnorm([targets(:).position]-obj.antenna.position)';
0188     <span class="keyword">end</span> <span class="comment">% trueRange()</span>
0189     
0190     <a name="_sub17" href="#_subfunctions" class="code">function doppler = measuredDoppler(obj,targets)</a>
0191       <span class="comment">% Calculate the measured doppler shift of each target in the list,</span>
0192       <span class="comment">% accounting for ambiguities</span>
0193       doppler = zeros(numel(targets),1); <span class="comment">% Pre-allocate</span>
0194       <span class="keyword">for</span> ii = 1:length(doppler)
0195         <span class="comment">% Calculate the shift that would be measured with no ambiguities.</span>
0196         <span class="comment">% NOTE: We define negative doppler as moving towards the radar, so there</span>
0197         <span class="comment">% is a sign change.</span>
0198         position_vec = targets(ii).position - obj.antenna.position;
0199         position_vec = position_vec / norm(position_vec);
0200         true_doppler = -dot(targets(ii).velocity,position_vec)*<span class="keyword">...</span>
0201           2/obj.antenna.wavelength;
0202         
0203         <span class="keyword">if</span> (abs(true_doppler) &lt; obj.prf/2)
0204           <span class="comment">% Shift can be measured unambiguously, send it straight to the</span>
0205           <span class="comment">% output</span>
0206           doppler(ii) = true_doppler;
0207         <span class="keyword">elseif</span> mod(true_doppler,obj.prf) &lt; obj.prf/2
0208           <span class="comment">% Aliased doppler is within the measurable range; output it</span>
0209           aliased_doppler = mod(true_doppler,obj.prf);
0210           doppler(ii) = aliased_doppler;
0211         <span class="keyword">elseif</span> mod(true_doppler,obj.prf) &gt; obj.prf/2
0212           <span class="comment">% Aliased doppler is still ambiguous. Shift it into the measurable</span>
0213           <span class="comment">% range</span>
0214           aliased_doppler = mod(true_doppler,obj.prf);
0215           doppler(ii) = aliased_doppler-obj.prf;
0216         <span class="keyword">end</span> <span class="comment">% if</span>
0217       <span class="keyword">end</span> <span class="comment">% for</span>
0218     <span class="keyword">end</span> <span class="comment">% measuredDoppler()</span>
0219     
0220     <a name="_sub18" href="#_subfunctions" class="code">function velocity = measuredVelocity(obj,targets)</a>
0221       <span class="comment">% Calculate the velocity measured by the radar for each target in the</span>
0222       <span class="comment">% list. In this case, it's easier to find measured doppler and convert</span>
0223       <span class="comment">% from there</span>
0224       
0225       doppler = obj.measuredDoppler(targets);
0226       velocity = doppler*obj.antenna.wavelength/2;
0227       
0228     <span class="keyword">end</span> <span class="comment">% measuredVelocity()</span>
0229     
0230     <a name="_sub19" href="#_subfunctions" class="code">function phase = roundTripPhase(obj,targets)</a>
0231       
0232       <span class="comment">% Calculate the constant round-trip phase term for each target in the list</span>
0233       phase = -4*pi*obj.measuredRange(targets)/obj.antenna.wavelength;
0234       phase = mod(phase,2*pi);
0235       
0236     <span class="keyword">end</span> <span class="comment">% roundTripPhase()</span>
0237     
0238     <a name="_sub20" href="#_subfunctions" class="code">function power = receivedPower(obj,targets)</a>
0239       <span class="comment">% Calculates the received power for the list of targets from the RRE.</span>
0240       <span class="comment">% For now, assuming monostatic configuration (G_t = G_r)</span>
0241       
0242       <span class="comment">% Convert everything to linear for our calculations, but keep track of</span>
0243       <span class="comment">% whether or not we need to go back to dB</span>
0244       was_db = false;
0245       <span class="keyword">if</span> (strcmpi(obj.scale,<span class="string">'db'</span>))
0246         obj.scale = <span class="string">'linear'</span>;
0247         was_db = true;
0248       <span class="keyword">end</span>
0249       
0250       <span class="comment">% Get the azimuth and elevation of the targets</span>
0251       pos_matrix = [targets.position]';
0252       [az,el] = cart2sph(pos_matrix(:,1),pos_matrix(:,2),pos_matrix(:,3));
0253       <span class="comment">% Convert to degree if necessary</span>
0254       <span class="keyword">if</span> strncmpi(obj.antenna.angle_unit,<span class="string">'Degrees'</span>,1)
0255         az = (180/pi)*az;
0256         el = (180/pi)*el;
0257       <span class="keyword">end</span>
0258       
0259       <span class="comment">% Get the antenna gain in the azimuth/elevation of the targets. Also</span>
0260       <span class="comment">% convert to linear units if we're working in dB</span>
0261       G = obj.antenna.power_gain*obj.antenna.normVoltageGain(az,el).^2;
0262       <span class="comment">% Get the target ranges as seen by the radar</span>
0263       ranges = obj.trueRange(targets);
0264       <span class="comment">% Calculate the power from the RRE for each target</span>
0265       power = obj.antenna.tx_power*G.^2*obj.antenna.wavelength^2.*<span class="keyword">...</span>
0266         [targets(:).rcs]'./((4*pi)^3*obj.loss_system*ranges.^4);
0267       
0268       <span class="comment">% Convert back to dB if necessary</span>
0269       <span class="keyword">if</span> was_db
0270         power = 10*log10(power);
0271         obj.scale = <span class="string">'db'</span>;
0272       <span class="keyword">end</span>
0273     <span class="keyword">end</span> <span class="comment">% receivedPower()</span>
0274     
0275     <a name="_sub21" href="#_subfunctions" class="code">function pulses = pulseBurstWaveform(obj)</a>
0276       <span class="comment">% Returns an LM x 1 pulse train, where L is the number of fast time</span>
0277       <span class="comment">% samples of the waveform and M is the number of pulses to be</span>
0278       <span class="comment">% transmitted</span>
0279       
0280       <span class="comment">% Pad pulse to the PRI length</span>
0281       num_zeros = (obj.pri-obj.waveform.pulse_width)*obj.waveform.samp_rate;
0282       padded_pulse = [obj.waveform.data;zeros(num_zeros,1)];
0283       <span class="comment">% Stack num_pulses padded pulses on top of each other</span>
0284       pulses = repmat(padded_pulse,obj.num_pulses,1);
0285     <span class="keyword">end</span> <span class="comment">% pulseBurstWaveform()</span>
0286     
0287     <a name="_sub22" href="#_subfunctions" class="code">function mf = pulseBurstMatchedFilter(obj)</a>
0288       <span class="comment">% Returns an LM x 1 pulse train containing M copies of the length-L</span>
0289       <span class="comment">% matched filter vector</span>
0290       mf = flipud(conj(obj.pulseBurstWaveform()));
0291     <span class="keyword">end</span> <span class="comment">% pulseBurstMatchedFilter()</span>
0292     
0293     <a name="_sub23" href="#_subfunctions" class="code">function pulses = pulseMatrix(obj)</a>
0294       <span class="comment">% Returns an L x M pulse train, where L is the number of fast time</span>
0295       <span class="comment">% samples of the waveform and M is the number of pulses to be</span>
0296       <span class="comment">% transmitted</span>
0297       
0298       <span class="comment">% Pad pulse to the PRI length</span>
0299       num_zeros = (obj.pri-obj.waveform.pulse_width)*obj.waveform.samp_rate;
0300       padded_pulse = [obj.waveform.data;zeros(round(num_zeros),1)];
0301       <span class="comment">% Stack num_pulses padded pulses on top of each other</span>
0302       pulses = repmat(padded_pulse,1,obj.num_pulses);
0303       
0304     <span class="keyword">end</span> <span class="comment">% pulseMatrix()</span>
0305     
0306     <a name="_sub24" href="#_subfunctions" class="code">function out = simulateTargets(obj,targets,data)</a>
0307       
0308       <span class="comment">% Simulate reflections from each target in the list on the given</span>
0309       <span class="comment">% input data, including a time delay, amplitude scaling, and doppler</span>
0310       <span class="comment">% shift.</span>
0311       <span class="comment">%</span>
0312       <span class="comment">% INPUTS:</span>
0313       <span class="comment">%  - targets: The list of target objects</span>
0314       <span class="comment">%  - data: The data in which target responses are injected</span>
0315       
0316       <span class="comment">% All calculations should be in linear units, so convert to linear if</span>
0317       <span class="comment">% in dB</span>
0318       was_db = false;
0319       <span class="keyword">if</span> (strcmpi(obj.scale,<span class="string">'db'</span>))
0320         obj.scale = <span class="string">'linear'</span>;
0321         was_db = true;
0322       <span class="keyword">end</span>
0323       
0324       <span class="comment">% Simulate the response of each target in the list on the input pulses.</span>
0325       <span class="comment">% This response includes the range-dependent target delay, the target</span>
0326       <span class="comment">% amplitude (from the RRE), and the target doppler shift</span>
0327       
0328       <span class="comment">% Input is a vector. Reshape to a matrix to do the calculations</span>
0329       was_vector = false;
0330       <span class="keyword">if</span> size(data,2) == 1
0331         data = reshape(data,floor(length(data)/obj.num_pulses),obj.num_pulses);
0332         was_vector = true;
0333       <span class="keyword">end</span>
0334       
0335       out = zeros(size(data)); <span class="comment">% Pre-allocate the output matrix</span>
0336       <span class="comment">% Loop through all PRIs in the input data and create a scaled and</span>
0337       <span class="comment">% shifted copy for each target. The output for each PRI is the</span>
0338       <span class="comment">% superposition of these pulses</span>
0339       <span class="keyword">for</span> ii = 1:obj.num_pulses
0340         <span class="comment">% The true range of each target (used to ensure we don't include</span>
0341         <span class="comment">% ambiguous target returns before the pulse is actually received</span>
0342         true_ranges = obj.trueRange(targets);
0343         <span class="comment">% The range of each target as seen from the radar</span>
0344         ranges = obj.measuredRange(targets);
0345         <span class="comment">% The possibly ambiguous sample delays of each target</span>
0346         delays = (2*ranges/obj.const.c)*obj.waveform.samp_rate;
0347         <span class="comment">% The doppler shifts and amplitude for each target</span>
0348         dopp_shifts = exp(1i*2*pi*obj.measuredDoppler(targets)*obj.pri*ii);
0349         amplitude_scaling = sqrt(obj.receivedPower(targets));
0350         <span class="keyword">for</span> jj = 1:length(targets)
0351           <span class="comment">% If we have not been transmitting long enough to see a target, its</span>
0352           <span class="comment">% return should not be added into the received signal until we have</span>
0353           <span class="comment">% listened long enough to see it. For example, if a target is at</span>
0354           <span class="comment">% 1.5*r_unambig, it will not be visible until the second pulse.</span>
0355           <span class="keyword">if</span> true_ranges(jj) &lt; obj.range_unambig*ii
0356             <span class="comment">% Delay the sequence</span>
0357             target_return = Radar.delaySequence(data(:,ii),delays(jj));
0358             <span class="comment">% Scale the sequence by the RRE and doppler shift it according to</span>
0359             <span class="comment">% the target doppler</span>
0360             target_return = target_return*dopp_shifts(jj)*amplitude_scaling(jj);
0361             <span class="comment">% Add the result to the output of the current pulse</span>
0362             out(:,ii) = out(:,ii) + target_return;
0363             
0364             <span class="comment">% Shift the target to its position for the next PRI</span>
0365             targets(jj).position = targets(jj).position + <span class="keyword">...</span>
0366               targets(jj).velocity*obj.pri;
0367           <span class="keyword">end</span>
0368         <span class="keyword">end</span>
0369       <span class="keyword">end</span>
0370       
0371       <span class="comment">% Convert back to a column vector if necessary</span>
0372       <span class="keyword">if</span> was_vector
0373         out = reshape(out,numel(out),1);
0374       <span class="keyword">end</span>
0375       
0376       <span class="comment">% Convert back to dB if necessary</span>
0377       <span class="keyword">if</span> was_db
0378         obj.scale = <span class="string">'db'</span>;
0379       <span class="keyword">end</span>
0380       
0381     <span class="keyword">end</span> <span class="comment">% simulateTargets()</span>
0382     
0383     <a name="_sub25" href="#_subfunctions" class="code">function out = simulateTargetsPulseBurst(obj,targets,data)</a>
0384       <span class="comment">% Simulate the effects of each target in the list on the input pulse burst</span>
0385       <span class="comment">% waveform. Target effects are applied on a per-sample basis, but the stop</span>
0386       <span class="comment">% and hop model is assumed so the amplitudes, delays, and doppler shifts</span>
0387       <span class="comment">% are only calculated once per pulse. This method produces an identical</span>
0388       <span class="comment">% output as simulateTargets(), but it's about 10x slower so it isn't</span>
0389       <span class="comment">% actually used in project 2.</span>
0390       
0391       was_db = false;
0392       <span class="keyword">if</span> (strcmpi(obj.scale,<span class="string">'db'</span>))
0393         obj.scale = <span class="string">'linear'</span>;
0394         was_db = true;
0395       <span class="keyword">end</span>
0396       
0397       <span class="comment">% Time indices of the start of each pulse</span>
0398       Tadc = 1/obj.waveform.samp_rate;
0399       t = (0:Tadc:obj.pri*obj.num_pulses-Tadc)';
0400       pri_length = obj.pri*obj.waveform.samp_rate;
0401       out = zeros(size(data));
0402       <span class="comment">% Get the shifted returns for each target then sum them together</span>
0403       measured_range = 0;
0404       delay = 0;
0405       dopp_shift = 0;
0406       amplitude = 0;
0407       <span class="keyword">for</span> ii = 1:length(targets)
0408         <span class="keyword">for</span> jj = 1:numel(data)
0409           <span class="comment">% Calculate new target parameters ONLY on the first sample of each new</span>
0410           <span class="comment">% pulse (stop and hop assumption)</span>
0411           <span class="keyword">if</span> (jj == 1 || ~mod(jj,pri_length))
0412             measured_range = obj.measuredRange(targets(ii));
0413             delay = round((2*measured_range/obj.const.c)*obj.waveform.samp_rate);
0414             dopp_shift = exp(1i*2*pi*obj.trueDoppler(targets(ii))*t(jj));
0415             amplitude = sqrt(obj.receivedPower(targets(ii)));
0416           <span class="keyword">end</span>
0417           <span class="comment">% Scale and shift each sample according to the above calculations</span>
0418           <span class="keyword">if</span> jj &gt; delay
0419             out(jj) = out(jj) + data(jj-delay)*amplitude*dopp_shift;
0420           <span class="keyword">end</span>
0421         <span class="keyword">end</span>
0422       <span class="keyword">end</span>
0423       
0424       <span class="comment">% Convert back to dB if necessary</span>
0425       <span class="keyword">if</span> was_db
0426         obj.scale = <span class="string">'db'</span>;
0427       <span class="keyword">end</span>
0428     <span class="keyword">end</span> <span class="comment">% simulateTargetsPulseBurst()</span>
0429     
0430     <a name="_sub26" href="#_subfunctions" class="code">function [mf_resp,range_axis] = matchedFilterResponse(obj,data)</a>
0431       
0432       <span class="comment">% Calculate the matched filter response of the given input data using</span>
0433       <span class="comment">% the waveform object associated with the radar</span>
0434       <span class="comment">%</span>
0435       <span class="comment">% INPUTS:</span>
0436       <span class="comment">%  - data: The fast time data to be filtered. This can be either an</span>
0437       <span class="comment">%          LM x 1 pulse train or an L x M matrix, where L is the</span>
0438       <span class="comment">%          number of fast time samples and M is the number of pulses.</span>
0439       <span class="comment">%</span>
0440       <span class="comment">% OUTPUTS:</span>
0441       <span class="comment">%  - mf_resp: The calculated matched filter response</span>
0442       <span class="comment">%  - range_axis: The ranges corresponding to each delay in the</span>
0443       <span class="comment">%                matched filter output</span>
0444       
0445       <span class="comment">% Input is a vector. Reshape to a matrix to do the calculations</span>
0446       <span class="keyword">if</span> size(data,2) == 1
0447         data = reshape(data,floor(length(data)/obj.num_pulses),obj.num_pulses);
0448       <span class="keyword">end</span>
0449       
0450       mf_length = size(obj.waveform.data,1)+size(data,1)-1;
0451       <span class="comment">% Pad the matched filter and data vector (or matrix) to the size of</span>
0452       <span class="comment">% the matched filter output</span>
0453       waveform_norm = obj.waveform.data ./ norm(obj.waveform.data);
0454       mf = [flipud(conj(waveform_norm));<span class="keyword">...</span>
0455         zeros(mf_length-size(waveform_norm,1),1)];
0456       data = [data;zeros(mf_length-size(data,1),size(data,2))];
0457       <span class="comment">% Calculate the matched filter output in the frequency domain</span>
0458       mf_resp = zeros(size(data));
0459       <span class="keyword">for</span> ii = 1:size(data,2)
0460         mf_resp(:,ii) = ifft(fft(data(:,ii)).*fft(mf));
0461       <span class="keyword">end</span>
0462       <span class="comment">% Calculate the corresponding range axis for the matched filter</span>
0463       <span class="comment">% response, where range 0 corresponds to a sample delay equal to the</span>
0464       <span class="comment">% length of the transmitted waveform</span>
0465       idx = (1:size(mf_resp,1))';
0466       time_axis = (idx-length(obj.waveform.data))/obj.waveform.samp_rate;
0467       range_axis = time_axis*(obj.const.c/2);
0468       
0469     <span class="keyword">end</span> <span class="comment">% matchedFilterResponse()</span>
0470     
0471     <a name="_sub27" href="#_subfunctions" class="code">function [rd_map,velocity_axis] = dopplerProcessing(obj,data,oversampling)</a>
0472       
0473       <span class="comment">% Perform doppler processing on the matched filtered data</span>
0474       <span class="comment">%</span>
0475       <span class="comment">% INPUTS:</span>
0476       <span class="comment">%  - data: A P x M matrix of matched filter vectors, where P is the</span>
0477       <span class="comment">%          length of the matched filter output and M is the number of</span>
0478       <span class="comment">%          pulses.</span>
0479       <span class="comment">%  - oversampling: The doppler oversampling rate</span>
0480       <span class="comment">%</span>
0481       <span class="comment">% OUTPUTS:</span>
0482       <span class="comment">%  - rd_map: The range doppler map</span>
0483       <span class="comment">%  - velocity_axis: The velocity values of each doppler bin</span>
0484       
0485       narginchk(2,3);
0486       <span class="comment">% Set default arguments</span>
0487       <span class="keyword">if</span> (nargin == 2)
0488         oversampling = 1;
0489       <span class="keyword">end</span>
0490       
0491       <span class="comment">% Input is a vector. Reshape to a matrix to do the calculations</span>
0492       <span class="keyword">if</span> size(data,2) == 1
0493         data = reshape(data,floor(length(data)/obj.num_pulses),obj.num_pulses);
0494       <span class="keyword">end</span>
0495       <span class="comment">% Perform doppler processing over all the pulses</span>
0496       rd_map = fftshift(fft(data,obj.num_pulses*oversampling,2),2);
0497       <span class="comment">% Create the doppler axis for the range-doppler map</span>
0498       velocity_step = 2*obj.velocity_unambig/obj.num_pulses;
0499       velocity_axis = (-obj.velocity_unambig:velocity_step:<span class="keyword">...</span>
0500         obj.velocity_unambig-velocity_step)';
0501       
0502     <span class="keyword">end</span> <span class="comment">% dopplerProcessing()</span>
0503     
0504     <a name="_sub28" href="#_subfunctions" class="code">function snr = SNR(obj,targets)</a>
0505       <span class="comment">% Compute the SNR for each target in the input list</span>
0506       <span class="keyword">if</span> (strcmpi(obj.scale,<span class="string">'db'</span>))
0507         snr = obj.receivedPower(targets) - obj.power_noise;
0508       <span class="keyword">else</span>
0509         snr = obj.receivedPower(targets) / obj.power_noise;
0510       <span class="keyword">end</span>
0511     <span class="keyword">end</span>
0512   <span class="keyword">end</span>
0513   
0514   <span class="comment">%% Static Methods</span>
0515   methods (Static)
0516     
0517     <a name="_sub29" href="#_subfunctions" class="code">function out = delaySequence(data,delay)</a>
0518       <span class="comment">% Delay the input vector by the given delay</span>
0519       <span class="comment">% INPUTS:</span>
0520       <span class="comment">%  - data: The data to be delayed</span>
0521       <span class="comment">%  - delay: The number of samples to delay the data</span>
0522       <span class="comment">%</span>
0523       <span class="comment">% OUTPUT: The delayed sequence</span>
0524       delay = round(delay); <span class="comment">% Only consider integer sample delays</span>
0525       delayed_seq_len = size(data,1)+max(0,delay);
0526       out = zeros(delayed_seq_len,1);
0527       <span class="comment">% Insert the data after the given number of delay samples</span>
0528       tmp = data;
0529       out(1+delay:delayed_seq_len) = tmp;
0530       <span class="comment">% Keep the output sequence the same size as the input. All data</span>
0531       <span class="comment">% delayed past the original sequence is truncated.</span>
0532       out = out(1:length(data),:);
0533       
0534     <span class="keyword">end</span>
0535     
0536   <span class="keyword">end</span>
0537   
0538 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Mon 19-Apr-2021 11:30:41 by <strong><a href="https://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003-2019</address>
</body>
</html>